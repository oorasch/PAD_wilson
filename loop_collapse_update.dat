void loop_col_update(const int neib[][4], const vector<int>& coords, const vector<vector<int>>& sig_link, const vector<double>& I_bessel, double& detM, vector<int>& s_site, vector<int>& plaq_occ, vector<vector<int>>& k_link)
{
	std::uniform_real_distribution<double> uniform_distribution(0.0,1.0);
	vector<int> s_site_prime = s_site;
	vector<int> k_link_prime (4, 0), coords_tmp (2, 0);
	int delta;
	vector<double> M_prime (constants::V*constants::V, 0.0);
	double detM_prime = 0.0;
	double rho = 2.0*2.0;
	//int delta_L = 2;
	
	if(k_link[coords.at(0)][0] == 0)//loop in time direction
	{
		delta = k_link[coords.at(1)][0];
		delta_p = delta;
		coords_tmp.at(0) = coords.at(1);
		coords_tmp.at(1) = coords.at(2);
		//#######################################################
		s_site_prime.at(coords_tmp.at(0)) = 1;
		s_site_prime.at(coords_tmp.at(1)) = 1;	
		k_link_prime.at(0) = 0; //for coords.at(0) in dir 1
		k_link_prime.at(1) = 0;
		k_link_prime.at(2) = 0;
		k_link_prime.at(3) = delta;
	}
	else if(k_link[coords.at(0)][1] == 0)//loop in spatial dierction
	{
		delta = k_link[coords.at(3)][1];
		delta_p = -delta;
		coords_tmp.at(0) = coords.at(2);
		coords_tmp.at(1) = coords.at(3);
		//#######################################################
		s_site_prime.at(coords_tmp.at(0)) = 1;
		s_site_prime.at(coords_tmp.at(1)) = 1;
		k_link_prime.at(0) = delta;
		k_link_prime.at(1) = 0;
		k_link_prime.at(2) = 0;
		k_link_prime.at(3) = 0;
	}
	else if(k_link[coords.at(3)][1] == 0) //loop in spatial direction
	{
		delta = k_link[coords.at(0)][1];
		delta_p = delta;
		coords_tmp.at(0) = coords.at(0);
		coords_tmp.at(1) = coords.at(1);
		//#######################################################
		s_site_prime.at(coords_tmp.at(0)) = 1;
		s_site_prime.at(coords_tmp.at(1)) = 1;
		k_link_prime.at(0) = 0;
		k_link_prime.at(1) = 0;
		k_link_prime.at(2) = delta;
		k_link_prime.at(3) = 0;
	}
	else if(k_link[coords.at(1)][0] == 0)//loop in time direction//loop in temporal direction
	{
		delta = k_link[coords.at(0)][0];
		delta_p = -delta;
		coords_tmp.at(0) = coords.at(0);
		coords_tmp.at(1) = coords.at(3);
		//#######################################################
		s_site_prime.at(coords_tmp.at(0)) = 1;
		s_site_prime.at(coords_tmp.at(1)) = 1;
		k_link_prime.at(0) = 0;
		k_link_prime.at(1) = delta;
		k_link_prime.at(2) = 0;
		k_link_prime.at(3) = 0;
		
	}

	//fill the fermion matrix
	calc_M_array(neib, sig_link, s_site_prime, M_prime);

	//calculate the log of the determinant
	detM_prime = det(constants::V, M_prime);

	if(detM_prime > 0.0) //catch the case detM = 0
	{
	 	rho *= detM_prime/detM;
		rho *= I_bessel.at(abs(plaq_occ.at(coords.at(0)) + delta_p))/I_bessel.at(abs(plaq_occ.at(coords.at(0))));
		if(delta_p > 0) rho *= sqrt(constants::eta/constants::eta_bar);
			else 					rho /= sqrt(constants::eta/constants::eta_bar);
	
		if(rho >= 1.0)
				{
					s_site.at(coords_tmp.at(0)) = 0;
					s_site.at(coords_tmp.at(1)) = 0;
	
					plaq_occ.at(coords.at(0)) += delta_p; //
	
					detM = detM_prime; // store the fermion determinant
	
					//change the loop configuration
					k_link[coords.at(0)][1] = k_link_prime.at(0);
					k_link[coords.at(1)][0] = k_link_prime.at(1);
					k_link[coords.at(3)][1] = k_link_prime.at(2);
					k_link[coords.at(0)][0] = k_link_prime.at(3);
				}
				else if(uniform_distribution(generator) < rho)
				{
					s_site.at(coords_tmp.at(0)) = 0;
					s_site.at(coords_tmp.at(1)) = 0;
	
					plaq_occ.at(coords.at(0)) += delta; //if delta introduces clock-wise flux, plaquette occupation must compensate that => anti-clock-wise and vice versa
	
					detM = detM_prime; // store the fermion determinant
	
					//change the loop configuration
					k_link[coords.at(0)][1] = k_link_prime.at(0);
					k_link[coords.at(1)][0] = k_link_prime.at(1);
					k_link[coords.at(3)][1] = k_link_prime.at(2);
					k_link[coords.at(0)][0] = k_link_prime.at(3);
				}
		}
}
